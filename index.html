<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Интерактивная карта — метки, CSV, localStorage</title>

  <style>
    :root{
      --accent:#1e88e5;
      --bg:#fafafa;
      --panel-width:340px;
    }
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:#111}
    #map{position:absolute;left:0;right:0;top:0;bottom:0}
    /* Панель управления слева */
    .panel{
      position:fixed; z-index:999; top:16px; left:16px;
      width:var(--panel-width); max-width:calc(100% - 32px);
      background:#fff; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.12);
      padding:12px; overflow:auto; max-height:80vh;
    }
    .panel h3{margin:0 0 8px 0;font-size:18px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .controls button{
      background:var(--accent); color:#fff; border:none; padding:8px 10px; border-radius:6px; cursor:pointer;
      font-size:13px;
    }
    .controls button.secondary{background:#efefef;color:#222}
    .controls input[type=file]{display:none}
    .status{font-size:12px;color:#444;margin-bottom:8px}
    .marker-list{margin-top:8px}
    .marker-item{padding:6px;border-radius:6px;background:#f7f7f7;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center}
    .marker-item .meta{font-size:13px}
    .marker-item button{background:transparent;border:0;color:var(--accent);cursor:pointer}
    /* Модал форма */
    .modal{
      position:fixed;z-index:2000;left:50%;top:50%;transform:translate(-50%,-50%);
      width:520px;max-width:95%;background:#fff;padding:14px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.25);
      display:none;
    }
    .modal .row{display:flex;gap:8px;margin-bottom:8px}
    .modal label{font-size:13px;margin-bottom:4px;display:block}
    .modal input[type=text],.modal select{width:100%;padding:8px;border:1px solid #ddd;border-radius:6px}
    .modal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
    .modal .actions button{padding:8px 12px;border-radius:6px;border:0;cursor:pointer}
    .modal .actions .btn-cancel{background:#efefef}
    .modal .actions .btn-save{background:var(--accent);color:#fff}
    /* Балун: небольшой стиль для содержимого */
    .balloon-img{max-width:200px;max-height:120px;display:block;margin-top:8px;border-radius:6px}
    /* Инфо-подсказка */
    .hint{font-size:12px;color:#666;margin-bottom:6px}
    @media(max-width:600px){
      .panel{left:8px;right:8px;width:auto}
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel" id="panel">
    <h3>Управление метками</h3>
    <div class="controls">
      <button id="btnAdd">Добавить метку</button>
      <button id="btnExport" class="secondary">Экспорт CSV</button>
      <label class="secondary" style="display:inline-flex;align-items:center;padding:6px 8px;border-radius:6px;background:#efefef;cursor:pointer;">
        <input type="file" id="fileImport" accept=".csv"/>
        Импорт CSV
      </label>
      <button id="btnClear" class="secondary">Очистить все</button>
    </div>
    <div class="status" id="status">Режим добавления: <strong id="mode">выкл</strong></div>
    <div class="hint">Добавление: нажмите "Добавить метку", затем кликните на карте в нужном месте</div>

    <div style="margin-top:8px">
      <strong>Список меток</strong>
      <div class="marker-list" id="markerList"></div>
    </div>
  </div>

  <!-- Модал-форма для ввода данных метки -->
  <div class="modal" id="modal">
    <h3 id="modalTitle">Добавить метку</h3>
    <div class="form">
      <div style="margin-bottom:8px"><label>Координаты</label><div id="coordsText" style="font-size:13px;color:#333"></div></div>
      <div class="row">
        <div style="flex:1">
          <label>Название</label>
          <input type="text" id="inpName" placeholder="Название (пример: Кафе «Уют»)" />
        </div>
        <div style="width:140px">
          <label>Направление</label>
          <input type="text" id="inpCategory" placeholder="Категория" />
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Страна</label>
          <input type="text" id="inpCountry" placeholder="Страна" />
        </div>
        <div style="width:140px">
          <label>Город</label>
          <input type="text" id="inpCity" placeholder="Город" />
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Ссылка (URL)</label>
          <input type="text" id="inpLink" placeholder="https://..." />
        </div>
        <div style="width:140px">
          <label>Изображение (URL)</label>
          <input type="text" id="inpImage" placeholder="https://...jpg" />
        </div>
      </div>

      <div class="actions">
        <button class="btn-cancel" id="btnCancel">Отмена</button>
        <button class="btn-save" id="btnSave">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Яндекс.Карты API -->
  <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU"></script>

  <script>
    // === Конфигурация ===
    const STORAGE_KEY = 'myMapMarkers_v1';

    // === Переменные состояния ===
    let map;
    let markers = []; // массив объектов: {id, coords:[lat,lon], name, country, city, category, link, image}
    let ymMarkers = {}; // mapping id -> ymaps.Placemark
    let addMode = false;
    let pendingCoords = null; // coords выбранные для новой метки
    let editingId = null; // если редактируем существующую метку

    // === Инициализация карты ===
    ymaps.ready(init);
    function init(){
      map = new ymaps.Map('map', {
        center: [20,0],
        zoom: 2,
        controls: ['zoomControl','fullscreenControl']
      });

      // Загрузить сохранённые метки
      loadMarkersFromStorage();
      renderAllMarkers();

      // Обработчик клика по карте — только в addMode
      map.events.add('click', function(e){
        if(!addMode) return;
        pendingCoords = e.get('coords'); // [lat, lon]
        openModalForNewMarker(pendingCoords);
      });
    }

    // === UI элементы ===
    const btnAdd = document.getElementById('btnAdd');
    const btnExport = document.getElementById('btnExport');
    const fileImport = document.getElementById('fileImport');
    const btnClear = document.getElementById('btnClear');
    const statusMode = document.getElementById('mode');
    const markerList = document.getElementById('markerList');
    const modal = document.getElementById('modal');
    const coordsText = document.getElementById('coordsText');
    const inpName = document.getElementById('inpName');
    const inpCountry = document.getElementById('inpCountry');
    const inpCity = document.getElementById('inpCity');
    const inpCategory = document.getElementById('inpCategory');
    const inpLink = document.getElementById('inpLink');
    const inpImage = document.getElementById('inpImage');
    const btnCancel = document.getElementById('btnCancel');
    const btnSave = document.getElementById('btnSave');
    const modalTitle = document.getElementById('modalTitle');

    btnAdd.addEventListener('click', ()=>{
      addMode = !addMode;
      statusMode.textContent = addMode ? 'вкл — клик по карте' : 'выкл';
      btnAdd.style.background = addMode ? '#0b5ed7' : '';
      if(addMode){
        // подсказка: прокрутка панели, на карте появится tooltip-режим (мы не показываем курсор, просто ждём клик)
      }
    });

    btnExport.addEventListener('click', exportCSV);
    fileImport.addEventListener('change', handleImportFile);
    btnClear.addEventListener('click', ()=>{
      if(!confirm('Удалить все метки?')) return;
      markers = [];
      saveMarkersToStorage();
      clearYandexMarkers();
      renderMarkerList();
      alert('Все метки удалены');
    });

    btnCancel.addEventListener('click', ()=>{
      closeModal();
    });

    btnSave.addEventListener('click', ()=>{
      const name = inpName.value.trim();
      const country = inpCountry.value.trim();
      const city = inpCity.value.trim();
      const category = inpCategory.value.trim();
      const link = inpLink.value.trim();
      const image = inpImage.value.trim();
      if(!name){
        alert('Введите название');
        return;
      }
      // coords: either pendingCoords (adding) or existing marker coords (editing)
      let coords;
      if(editingId){
        // редактирование существующей метки
        const idx = markers.findIndex(m=>m.id===editingId);
        if(idx===-1){ alert('Ошибка: метка не найдена'); closeModal(); return; }
        coords = markers[idx].coords;
        markers[idx] = {...markers[idx], name, country, city, category, link, image};
        updatePlacemark(markers[idx]);
      } else {
        if(!pendingCoords){
          alert('Сначала кликните на карту, чтобы выбрать место для метки.');
          return;
        }
        coords = [Number(pendingCoords[0]), Number(pendingCoords[1])];
        const id = 'm' + Date.now();
        const m = { id, coords, name, country, city, category, link, image };
        markers.push(m);
        addPlacemark(m);
      }
      saveMarkersToStorage();
      renderMarkerList();
      closeModal();
    });

    // === Modal helpers ===
    function openModalForNewMarker(coords){
      editingId = null;
      pendingCoords = coords;
      modalTitle.textContent = 'Добавить метку';
      coordsText.textContent = `Ш: ${coords[0].toFixed(6)}, Д: ${coords[1].toFixed(6)}`;
      inpName.value = '';
      inpCountry.value = '';
      inpCity.value = '';
      inpCategory.value = '';
      inpLink.value = '';
      inpImage.value = '';
      showModal();
    }
    function openModalForEdit(marker){
      editingId = marker.id;
      pendingCoords = null;
      modalTitle.textContent = 'Редактировать метку';
      coordsText.textContent = `Ш: ${marker.coords[0].toFixed(6)}, Д: ${marker.coords[1].toFixed(6)}`;
      inpName.value = marker.name || '';
      inpCountry.value = marker.country || '';
      inpCity.value = marker.city || '';
      inpCategory.value = marker.category || '';
      inpLink.value = marker.link || '';
      inpImage.value = marker.image || '';
      showModal();
    }
    function showModal(){ modal.style.display='block'; }
    function closeModal(){ modal.style.display='none'; addMode=false; statusMode.textContent='выкл'; btnAdd.style.background=''; pendingCoords=null; editingId=null; }

    // === Storage ===
    function saveMarkersToStorage(){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(markers));
      }catch(e){
        console.error('storage save error', e);
      }
    }
    function loadMarkersFromStorage(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw) markers = JSON.parse(raw);
        else markers = [];
      }catch(e){
        markers = [];
      }
    }

    // === Рендер / ymaps ===
    function addPlacemark(m){
      const placemark = new ymaps.Placemark(m.coords, {
        hintContent: m.name || '',
        balloonContentHeader: `<strong>${escapeHtml(m.name || '')}</strong>`,
        balloonContentBody: buildBalloonBodyHtml(m)
      },{
        preset: 'islands#blueDotIcon',
        balloonMaxWidth: 320
      });
      placemark.events.add('click', function(){
        // при клике в балуне добавим кнопки через setContent, но мы уже задали content body
        // Чтобы кнопки работали — используем события делегирования после открытия балуна
        setTimeout(()=>attachBalloonButtons(m.id), 100);
      });
      map.geoObjects.add(placemark);
      ymMarkers[m.id] = placemark;
    }

    function updatePlacemark(m){
      const placemark = ymMarkers[m.id];
      if(placemark){
        placemark.properties.set({
          hintContent: m.name || '',
          balloonContentHeader: `<strong>${escapeHtml(m.name || '')}</strong>`,
          balloonContentBody: buildBalloonBodyHtml(m)
        });
      }
    }

    function clearYandexMarkers(){
      Object.keys(ymMarkers).forEach(id=>{
        try{ map.geoObjects.remove(ymMarkers[id]); }catch(e){}
      });
      ymMarkers = {};
    }

    function renderAllMarkers(){
      clearYandexMarkers();
      markers.forEach(addPlacemark);
      renderMarkerList();
    }

    function buildBalloonBodyHtml(m){
      let html = `<div style="font-size:13px">${escapeHtml(m.category||'')}</div>`;
      if(m.country || m.city){
        html += `<div style="font-size:13px;color:#444">${escapeHtml((m.city?m.city+', ':'') + (m.country||''))}</div>`;
      }
      if(m.link){
        const safe = escapeHtml(m.link);
        html += `<div style="margin-top:6px"><a href="${safe}" target="_blank" rel="noopener">Перейти по ссылке</a></div>`;
      }
      if(m.image){
        const safeImg = escapeHtml(m.image);
        html += `<img src="${safeImg}" alt="" class="balloon-img" onerror="this.style.display='none'">`;
      }
      // кнопки редактирования и удаления
      html += `<div style="margin-top:8px"><button data-action="edit" data-id="${m.id}" style="margin-right:8px;border:0;background:#0b5ed7;color:#fff;padding:6px 8px;border-radius:6px;cursor:pointer">Редактировать</button><button data-action="delete" data-id="${m.id}" style="border:0;background:#ef5350;color:#fff;padding:6px 8px;border-radius:6px;cursor:pointer">Удалить</button></div>`;
      return html;
    }

    // После открытия балуна — повесим слушатель на кнопки внутри него
    function attachBalloonButtons(id){
      const placemark = ymMarkers[id];
      if(!placemark) return;
      const balloon = placemark.balloon.getData().balloon;
      // Найти DOM внутри балуна. Немного хак — используем querySelector по атрибутам
      const container = document.querySelector('.ymaps-2-1-79-balloon__content') || document.querySelector('.ymaps-balloon-content');
      if(!container) return;
      // Делаем делегирование внутри контейнера
      container.querySelectorAll('button[data-action]').forEach(btn=>{
        btn.addEventListener('click', (e)=>{
          const action = btn.getAttribute('data-action');
          const id = btn.getAttribute('data-id');
          if(action==='edit') {
            const mm = markers.find(x=>x.id===id);
            if(mm) {
              openModalForEdit(mm);
            } else alert('Метка не найдена');
          } else if(action==='delete') {
            if(confirm('Удалить метку?')){
              deleteMarkerById(id);
              placemark.balloon.close();
            }
          }
        });
      });
    }

    function deleteMarkerById(id){
      const idx = markers.findIndex(m=>m.id===id);
      if(idx!==-1){
        markers.splice(idx,1);
        const placemark = ymMarkers[id];
        if(placemark) map.geoObjects.remove(placemark);
        delete ymMarkers[id];
        saveMarkersToStorage();
        renderMarkerList();
      }
    }

    // Список меток в панели
    function renderMarkerList(){
      markerList.innerHTML='';
      if(markers.length===0){
        markerList.innerHTML='<div style="font-size:13px;color:#666;margin-top:8px">Меток пока нет</div>';
        return;
      }
      markers.slice().reverse().forEach(m=>{
        const div = document.createElement('div');
        div.className='marker-item';
        const left = document.createElement('div');
        left.className='meta';
        left.innerHTML = `<strong>${escapeHtml(m.name)}</strong><div style="font-size:12px;color:#444">${escapeHtml((m.city?m.city+', ':'')+(m.country||''))}</div>`;
        const right = document.createElement('div');
        right.innerHTML = `<button title="Перейти к метке" data-go="${m.id}">Перейти</button>`;
        right.querySelector('button').addEventListener('click', ()=>{
          const placemark = ymMarkers[m.id];
          if(placemark){
            map.setCenter(m.coords, 12, {checkZoomRange:true});
            placemark.balloon.open();
          }
        });
        div.appendChild(left); div.appendChild(right);
        markerList.appendChild(div);
      });
    }

    // === CSV: экспорт и импорт ===
    function exportCSV(){
      if(markers.length===0){ alert('Нет меток для экспорта'); return; }
      const header = ['name','country','city','category','link','image','latitude','longitude'];
      const rows = [header.join(',')];
      markers.forEach(m=>{
        const row = [
          csvEscape(m.name),
          csvEscape(m.country||''),
          csvEscape(m.city||''),
          csvEscape(m.category||''),
          csvEscape(m.link||''),
          csvEscape(m.image||''),
          m.coords[0],
          m.coords[1]
        ];
        rows.push(row.join(','));
      });
      const csvContent = rows.join('\n');
      const blob = new Blob([csvContent], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'markers.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function handleImportFile(e){
      const f = e.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = function(evt){
        const text = evt.target.result;
        parseCSV(text).then(rows=>{
          // rows: array of objects with keys from header
          importRows(rows);
        }).catch(err=>{
          alert('Ошибка разбора CSV: ' + err);
        });
      };
      reader.readAsText(f,'utf-8');
      // сброс input чтобы можно было загрузить тот же файл снова при необходимости
      e.target.value = '';
    }

    async function importRows(rows){
      if(!Array.isArray(rows) || rows.length===0){ alert('CSV пуст или неверный'); return; }
      // rows are objects: header -> value
      // For each row: if latitude & longitude present -> use them
      // else try to geocode by "city, country" (if present). If geocode fails -> place at map center
      const toAdd = [];
      for(const r of rows){
        const name = (r.name||'').trim();
        if(!name) continue; // skip empty
        const country = (r.country||'').trim();
        const city = (r.city||'').trim();
        const category = (r.category||'').trim();
        const link = (r.link||'').trim();
        const image = (r.image||'').trim();
        const latRaw = (r.latitude||r.lat||'').toString().trim();
        const lonRaw = (r.longitude||r.lon||'').toString().trim();
        let coords = null;
        if(latRaw && lonRaw && !isNaN(Number(latRaw)) && !isNaN(Number(lonRaw))){
          coords = [Number(latRaw), Number(lonRaw)];
        } else {
          // try geocode by city + country
          const q = [city, country].filter(Boolean).join(', ');
          if(q){
            try{
              const res = await ymaps.geocode(q, {results:1});
              const obj = res.geoObjects.get(0);
              if(obj){
                const c = obj.geometry.getCoordinates();
                coords = [c[0], c[1]];
              }
            }catch(e){
              console.warn('geocode error for', q, e);
            }
          }
        }
        if(!coords){
          // fallback to map center
          const center = map.getCenter();
          coords = [center[0], center[1]];
        }
        const id = 'm' + Date.now() + Math.floor(Math.random()*999);
        toAdd.push({id, coords, name, country, city, category, link, image});
      }

      // Добавляем все и рендерим
      let added = 0;
      toAdd.forEach(m=>{
        markers.push(m);
        addPlacemark(m);
        added++;
      });
      saveMarkersToStorage();
      renderMarkerList();
      alert(`Импортировано ${added} меток`);
    }

    // === Вспомогательные: CSV парсер (поддерживает кавычки) ===
    function csvEscape(str){
      if(str===null || str===undefined) return '';
      const s = String(str);
      if(s.includes('"') || s.includes(',') || s.includes('\n')){
        return '"' + s.replace(/"/g,'""') + '"';
      }
      return s;
    }

    function parseCSV(text){
      return new Promise((resolve, reject)=>{
        try{
          const lines = [];
          let cur = '';
          let inQuotes = false;
          let row = [];
          for(let i=0;i<text.length;i++){
            const ch = text[i];
            const next = text[i+1];
            if(ch === '"'){
              if(inQuotes && next === '"'){ // escaped quote
                cur += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
            } else if(ch === ',' && !inQuotes){
              row.push(cur);
              cur = '';
            } else if((ch === '\n' || ch === '\r') && !inQuotes){
              // handle \r\n or \n
              if(ch === '\r' && next === '\n'){ i++; } // skip one
              row.push(cur);
              lines.push(row);
              row = [];
              cur = '';
            } else {
              cur += ch;
            }
          }
          if(cur !== '' || row.length>0){
            row.push(cur);
            lines.push(row);
          }
          if(lines.length === 0) return resolve([]);
          // header:
          const header = lines[0].map(h => (h||'').trim());
          const rows = [];
          for(let r=1;r<lines.length;r++){
            const arr = lines[r];
            // skip empty lines
            if(arr.length===1 && arr[0].trim()==='') continue;
            const obj = {};
            for(let c=0;c<header.length;c++){
              obj[header[c]] = arr[c] !== undefined ? arr[c] : '';
            }
            rows.push(obj);
          }
          resolve(rows);
        }catch(e){
          reject(e);
        }
      });
    }

    // === Утилиты ===
    function escapeHtml(str){
      if(!str) return '';
      return String(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#039;');
    }

    // === Загрузка/иниц. ===
    // После загрузки страницы: рендерим список (если карта ещё не готова — функция вызовет при init)
    document.addEventListener('DOMContentLoaded', ()=>{
      // Если markers уже загружены при ymaps.ready -> renderAllMarkers позаботится
      renderMarkerList();
    });

    // === Дополнительно: редактирование удаление через контекст ===
    // Ничего доп. не нужно — обработчик кнопок в балуне
  </script>
</body>
</html>
